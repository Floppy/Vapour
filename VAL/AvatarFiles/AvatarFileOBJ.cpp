//====---
// VAL
//----
// Vapour Technology All-Purpose Library
// Copyright 2000 Vapour Technology Ltd.
//
// AvatarFileOBJ.cpp - 04/10/2000 - James Smith
//	Wavefront OBJ export filter implementation
//
// $Id: AvatarFileOBJ.cpp,v 1.0 2000/10/04 16:27:08 waz Exp $
//

#include "stdafx.h"

#include "AvatarFileOBJ.h"
#include "AvatarFileProxy.h"
#include "ImageFileStore.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CImageFileStore g_oImageFileStore;

///////////////////
// CAvatarFileOBJ

CAvatarFileProxy<CAvatarFileOBJ> g_oAvatarProxyOBJ;

/////////////////////
// Member Functions

////////////////////
// Store Functions

CAvatarFileOBJ::CAvatarFileOBJ() {
   m_pszBasename = NULL;
} // CAvatarFileOBJ()

float CAvatarFileOBJ::GetFilterVersion() const {
	return GetVersion();
} // GetFilterVersion()

const char* CAvatarFileOBJ::GetFileExtension() const {
	return GetExtension();
} // GetFileExtension()

const char* CAvatarFileOBJ::GetFileTitle() const {
	return GetTitle();
} // GetFileTitle()

bool CAvatarFileOBJ::CanFilterLoadFile() const {
   return CanLoadFile();
} // CanFilterLoadFile();

bool CAvatarFileOBJ::CanFilterLoadStream() const {
   return CanLoadStream();
} // CanFilterLoadStream();

bool CAvatarFileOBJ::CanFilterSaveFile() const {
   return CanSaveFile();
} // CanFilterSaveFile();

bool CAvatarFileOBJ::CanFilterSaveStream() const {
   return CanSaveStream();
} // CanFilterSaveStream();

bool CAvatarFileOBJ::CanFilterLoadBPFile() const {
   return CanLoadBPFile();
} // CanFilterLoadBPFile();

bool CAvatarFileOBJ::CanFilterLoadBPStream() const {
   return CanLoadBPStream();
} // CanFilterLoadBPStream();

////////////////////////
// AvatarFile Functions

FRESULT CAvatarFileOBJ::Save(const char* pszFilename, CAvatar* pAvatar) const {

   if (pAvatar == NULL) return F_NO_DATA_TO_SAVE;
   FRESULT eResult = F_OK;

   // Work out base filename and store it
   char* pszLocalFilename = strdup(pszFilename);
   char* pszTemp = pszLocalFilename;
   while (strchr(pszTemp,'\\') != NULL) {
      pszTemp = strchr(pszTemp,'\\') + 1;
   }
   int iLength = (strchr(pszTemp,'.') - pszTemp);
   m_pszBasename = new char[iLength+1];
   memset(m_pszBasename,0,iLength+1);
   for (int i=0; i<iLength; i++) m_pszBasename[i] = pszTemp[i];
   free(pszLocalFilename);
   int iBaseNameLength = strlen(m_pszBasename);
   // Setup the export progress dialog
   g_poVAL->SetProgressMax("OBJSave",3 + pAvatar->NumTextures());
   g_poVAL->StepProgress("OBJSave");
   // Save OBJ to stream
   g_poVAL->SetProgressText("OBJSave","Saving OBJ file");
   ofstream osOutputStream(pszFilename);
	if (osOutputStream.good()) {
      pAvatar->CalculateNormals(true);
	   // Write header information
	   osOutputStream << "# Avatar generated by Vapour Technology\n";
	   osOutputStream << "#\n";
	   osOutputStream << "#\n\n";
      osOutputStream << "mtllib " << m_pszBasename << ".mtl\n";
	   // Write vertices
	   osOutputStream << "g\n";
	   osOutputStream << "\n# " << pAvatar->NumVertices() << " vertices\n";
	   const SPoint3D* pVertices = pAvatar->Vertices();
      int iNumVertices = pAvatar->NumVertices();
	   for (int v=0; v<iNumVertices; v++) {
		   osOutputStream << "v  " << pVertices[v].m_dComponents[0] << ' ' << pVertices[v].m_dComponents[1] << ' ' << pVertices[v].m_dComponents[2] << '\n';
	   }
      // Write normals
	   osOutputStream << "\n# " << pAvatar->NumVertices() << " normals\n";
      const SPoint3D* pVertexNormals = pAvatar->VertexNormals();
	   for (v=0; v<iNumVertices; v++) {
		   osOutputStream << "vn " << pVertexNormals[v].m_dComponents[0] << ' ' << pVertexNormals[v].m_dComponents[1] << ' ' << pVertexNormals[v].m_dComponents[2] << '\n';
	   }
      // Write texture coordinates
      osOutputStream << "\n# " << pAvatar->NumFaces()*3 << " texture vertices\n";
      const STriFace* pFaces = pAvatar->Faces();
      for (int f=0; f<pAvatar->NumFaces(); f++) {
         osOutputStream << "vt " << pFaces[f].m_sVertices[0].m_sTexCoord.dU << ' ' << 1.0-pFaces[f].m_sVertices[0].m_sTexCoord.dV << '\n';
         osOutputStream << "vt " << pFaces[f].m_sVertices[1].m_sTexCoord.dU << ' ' << 1.0-pFaces[f].m_sVertices[1].m_sTexCoord.dV << '\n';
         osOutputStream << "vt " << pFaces[f].m_sVertices[2].m_sTexCoord.dU << ' ' << 1.0-pFaces[f].m_sVertices[2].m_sTexCoord.dV << '\n';
      }
	   // Write Faces in sets
	   osOutputStream << "\n# " << pAvatar->NumFaces() << " elements\n";
      osOutputStream << "g " << m_pszBasename << '\n';
      osOutputStream << "s 1\n";
      for (int t=0; t<pAvatar->NumTextures(); t++) {   
	      osOutputStream << "usemtl " << m_pszBasename << '_' << (char)(t+'a') << '\n';
	      for (f=0; f<pAvatar->NumFaces(); f++) {
            if (pFaces[f].m_iTextureNumber == t) {
		         osOutputStream << "f ";
		         osOutputStream << pFaces[f].m_sVertices[0].m_iVertex+1 << '/' << (f*3)+1 << '/' << pFaces[f].m_sVertices[0].m_iVertex+1 << ' ';
		         osOutputStream << pFaces[f].m_sVertices[1].m_iVertex+1 << '/' << (f*3)+2 << '/' << pFaces[f].m_sVertices[1].m_iVertex+1 << ' ';
		         osOutputStream << pFaces[f].m_sVertices[2].m_iVertex+1 << '/' << (f*3)+3 << '/' << pFaces[f].m_sVertices[2].m_iVertex+1 << '\n';
            }
	      }
      }
      if (osOutputStream.bad()) eResult = F_FILE_ERROR;
	}
	osOutputStream.close();
   // Save images
   CImageFile* pImageFile = g_oImageFileStore.CreateByExtension("jpg");
   for (int t=0; t<pAvatar->NumTextures(); t++) {
      g_poVAL->StepProgress("OBJSave");
      char pszDisplay[256];
      sprintf(pszDisplay,"Saving JPEG texture %d", t);
      g_poVAL->SetProgressText("OBJSave",pszDisplay);
      char* pszTextureFilename = new char[iBaseNameLength+7];
      strcpy(pszTextureFilename,m_pszBasename);
      pszTextureFilename[iBaseNameLength] = '_';
      pszTextureFilename[iBaseNameLength+1] = t+'a';
      strcpy(pszTextureFilename+iBaseNameLength+2,".jpg");
      pAvatar->Texture(t)->Save(pszTextureFilename,pImageFile);
      delete [] pszTextureFilename;
   }
   // Write material file
   g_poVAL->StepProgress("OBJSave");
   g_poVAL->SetProgressText("OBJSave","Saving material file");
   char* pszMaterialFilename = new char[iBaseNameLength+5];
   strcpy(pszMaterialFilename,m_pszBasename);
   strcpy(pszMaterialFilename+iBaseNameLength,".mtl");
   ofstream osMaterialStream(pszMaterialFilename);
   delete [] pszMaterialFilename;
   for (t=0; t<pAvatar->NumTextures(); t++) {
      osMaterialStream << "newmtl " << m_pszBasename << '_' << (char)(t+'a') << "\n";
      osMaterialStream << "Kd 1 1 1\n";
      osMaterialStream << "Ns 0\n";
      osMaterialStream << "Ks 0 0 0\n";
      osMaterialStream << "illum 2\n";
      osMaterialStream << "map_Kd " << m_pszBasename << '_' << (char)(t+'a') << ".jpg\n";
   }
   osMaterialStream.close();
   // Finish
   g_poVAL->StepProgress("OBJSave");
   delete [] m_pszBasename;
   m_pszBasename = NULL;
   return eResult;
} // Save(const char* pszFilename, CAvatar* pAvatar)